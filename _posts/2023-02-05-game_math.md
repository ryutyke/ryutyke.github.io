---
title: "[GameMath] 게임 수학"
excerpt: "벡터, 행렬, 내적, 외적의 활용, 회전의 표현"

categories:
  - etc
tags:
  - [GameMath, matrix, vector, dot, cross]

permalink: /etc/game_math/

toc: true
toc_sticky: true

date: 2024-02-05 18:40:00
last_modified_at: 2024-02-05
---
<br>

# 벡터1

직선의 수 집합을 수직으로 배치해 평면을 표기하는 방식을 데카르트 좌표계(Cartesian coordinate system)라고 부른다.<br> 
두 개 이상의 실수를 곱집합으로 묶어 형성된 집합을 벡터 공간. 벡터 공간의 원소를 벡터(vector)라고 한다.

크기가 1인 벡터를 단위 벡터(unit vector)라고 하고, 모자를 씌워 표기한다.<br>
임의의 벡터를 단위 벡터로 만드는 작업을 정규화한다고 한다. 단위벡터 = 벡터 / 벡터크기

<br>

---

## 예제 (정규화)
X 입력과 Y 입력을 동시에 누르면 입력 벡터 값이 (1,1)이 되는데 이 크기는 루트2 라서 동시에 누를 때 더 빠르게 움직인다. 그래서 입력을 받은 인풋 벡터를 정규화하여 사용한다. <br>

---

n개의 스칼라 a와 n개의 벡터 v를 결합해 새로운 벡터를 생성하는 수식을 선형 결합이라고 한다.<br>
모든 a가 0이 아님에도 영벡터를 만들 수 있다면, 선형 결합에 사용된 벡터는 서로 '선형 종속의 관계'를 가진다고 표현한다.<br>
반대로 영벡터가 나오기 위해 모든 a값이 0이어야 한다면 '선형 독립의 관계'를 가진다고 한다.<br>
선형 독립의 관계를 가지는 벡터를 선형 결합하면 벡터 공간에 속한 모든 벡터를 생성할 수 있다.<br>
평면의 모든 점을 생성하기 위해서는 서로 평행하지 않은 2개의 벡터만 있으면 된다. (선형 독립).<br>
벡터 공간 내 모든 벡터를 생성할 수 있는 선형 독립 관계를 가지는 벡터의 집합을 기저(Basis)라고 한다. 기저에 속한 원소를 기저벡터라고 한다.<br>
(1,0), (0,1)로 구성된 집합을 표준기저라고 하며, 원소는 표준기저벡터라고 한다.<br>

임의의 벡터 (x,y)가 각 θ만큼 회전한 결과 (x', y')는<br>
x' = x cosθ – y sinθ<br>
y' = x sinθ + ycosθ<br>

<br>

---

arctan 함수를 통해 임의의 벡터 (x,y)와 x축과 이루는 사잇각을 얻어낼 수 있다.<br>
y/x로 tan 값을 얻고 arctan에 넣으면 사잇각이 나온다.<br>

<br>

---

극좌표계(Polar coordinate system)도 자주 쓰인다.
r = 루트(x^2 + y^2)
θ = arctan(y/x)
x = r cosθ
y = r sinθ

<br>

---

# 행렬
선형 변환을 표현할 때는 행과 열이 크기가 같은 정방행렬(square matrix)를 사용한다.<br>
행렬 곱셈은<br>
- 교환법칙 성립하지 않는다. (곱셈 순서 중요하다)
- 결합법칙 성립한다. (행렬 변환 여러 개를 미리 계산해둬도 됨. 행렬 쓰는 이유)

---

- 회전 변환행렬 (행 기준)
[x,y] [■(cosθ&sinθ@-sinθ&cosθ)] = (x cosθ – y sinθ, x sinθ + ycosθ)

<br>

---

역행렬이 존재하는지 파악할 수 있는 방법 : 행렬식(Determinant)<br>
2 x 2 행렬 [■(a&b@c&d)] 에서 행렬식 = ad - bc<br>
행렬식 값이 0인 선형 변환은 차원이 줄어들기 때문에 역행렬이 존재하지 않는다.<br>
서로 직교하고 크기가 1인 벡터로 이루어진 행렬을 직교행렬이라고 한다.<br>
직교행렬의 역행렬은 직교행렬의 전치행렬이다. 그 예시로 회전행렬이 있다.<br>
회전행렬의 역행렬은 기존 회전행렬을 전치하면 구할 수 있다.<br>

<br>

# 벡터2
벡터 공간에서 이동 연산을 위해 마지막 차원 값을 1로 한정한 부분 공간을 아핀 공간(affine space)이라고 부른다.

<br>

## 백터의 내적(Dot product)
벡터의 내적은 같은 차원의 두 벡터가 주어졌을 때, 벡터를 구성하는 각 성분을 곱한 후 이들을 더해 스칼라를 만들어내는 연산이다. 내적은 곱셈 기호와 동일한 가운뎃점을 사용한다.<br>
v1 = (a,b), v2 = (c,d), 	v1ᆞv2 = aᆞc + bᆞd = lv1l lv2l cosθ<br>
교환법칙은 성립하고, 결합법칙은 성립하지 않는다.

<br>

## 내적의 활용
### 스스로 내적
벡터 자기 자신을 내적하고 루트 씌우면 벡터의 크기를 구할 수 있다.

<br>

### 앞뒤 판별
목표물이 캐릭터의 앞에 있는지, 뒤에 있는지 구분하는 방법이다.<br>
v1ᆞv2 = lv1l lv2l cosθ 이기 때문에 내적이 양수면 사잇각이 (-90도, 90도), 내적이 0이면 사잇각이 -90도 또는 90도, 내적이 음수면 사잇각이 그 외의 각도이다. 따라서 v1 = 캐릭터의 시선, v2 = 캐릭터에서 목표물로 향하는 벡터 일 때, v1ᆞv2이,<br>
양수 : 캐릭터 앞에 목표물이 있다.<br>
음수 : 캐릭터 뒤에 목표물이 있다.<br>
0 : 캐릭터 옆에 목표물이 있다.

<br>

### 시야 판별
v1 = 캐릭터의 시선, v2 = 캐릭터에서 목표물로 향하는 벡터, 시야각이 b라고 하면<br>
v1과 v2를 정규화 시키고 내적하고 이를 시야각의 절반 b/2을 cos 한 것과 비교하면 목표물이 시야 내에 있는지 파악할 수 있다.<br>  
(v1과 v2를 정규화 시키고 내적) >= cos (b/2) : 목표물이 시야 내에 있음<br>
(v1과 v2를 정규화 시키고 내적) < cos (b/2) : 목표물이 시야 밖에 있음

<br>

### 조명 효과 (램버트 반사 모델)
빛을 받아 표면에서 반사되는 빛의 세기는 표면의 노멀 벡터와 광원으로 향하는 벡터 사잇각의 cos 함수에 비례한다는 내용.

<br>

### 투영 벡터 구하기
a벡터를 b벡터에 투영한 벡터 구하는 방법. 두 벡터 사잇각 θ. <br>
= (ㅣaㅣcos θ ) ᆞ b의 단위벡터<br>
b벡터 크기가 1이면,<br>
= (aᆞb)ᆞb

<br>

# 행렬2
오일러 각 : 회전하는 중심축과 각으로 표현된 회전량.<br>

언리얼엔진 왼손 좌표계 (z업 왼손 좌표계)<br>
소프트웨어마다 좌표계가 달라서, 오일러각 서로 변환하기 좋게 요(Yaw, 위), 롤(Roll, 앞), 피치(Pitch, 오른쪽) 사용.<br>

오일러 각 3차원 회전을 행렬로 표현하면, 각 축마다 행렬로 표현할 수 있다.<br>

- x축에 대한 회전 (행 기준)
[■(1&0&0@0&cos θ&sin⁡θ@0&-sin⁡θ&cos⁡θ )]
- y축에 대한 회전 (행 기준)
y축에 직교하는 평면은 xz평면이 아니라 zx 평면이기 때문에 좀 다르다.<br>
[■(cos θ&0&-sin⁡θ@0&1&0@sin⁡θ&0&cos⁡θ )]
- z축에 대한 회전 (행 기준)
[■(cos θ&sin⁡θ&0@-sin⁡θ&cos θ&0@0&0&1)]

이 세 행렬을 합치면 오일러 회전 행렬이 되는데 언리얼 엔진은 z -> x -> y 순서로 Yaw-Roll-Pitch 순서다. (FRotator에 그냥 넣어주면 알아서 하니깐~)<br>

오일러 각은 행렬로 회전 표현하면 9개의 실수 데이터가 필요한데, 오일러 각은 3개만 있으면 된다는 장점. 그러나 짐벌락 현상이 일어나는 단점.

<br>

# 외적 (Cross product)
외적은 X 기호를 사용한다.<br>
결과물로 스칼라가 나오는 내적과 달리 벡터가 결과물로 나온다.<br>
v1 = (x1, y1, z1), v2 = (x2, y2, z2) 의 외적은<br>
x1 y1 z1<br>
x2 y2 z2<br>
이렇게 해두고 신발끈 공식 쓰는 거다.<br>
v1 X v2 = (y1z2 – z1y2, z1x2 – x1z2, x1y2 – y1x2)

<br>

교환법칙과 결합법칙 모두 성립하지 않는다. 대신 v1 X v2 = -v2 X v1 이다.

<br>

## 외적의 활용

### 평행 판별
a X b = lal lbl sinθᆞn 이다. n은 n은 두 벡터에 수직인 단위 벡터이다.<br>
따라서 평행한 두 벡터 사이 외적은 (0, 0, 0), 영벡터가 된다.

<br>

### 노멀 벡터
결과물로 나오는 벡터가 노멀 벡터(법선 벡터)

<br>

### 좌우 방향 판별 (언리얼엔진 왼손 좌표계 기준)
캐릭터 시선 X 목표물이<br>
- 목표물이 캐릭터 시선의 왼쪽에 있으면 아래쪽 방향 벡터
- 목표물이 캐릭터 시선의 오른쪽에 있으면 위쪽 방향 벡터
- 앞 뒤에 있으면 0

<br>

벡터가 결과로 나와서 애매하기 때문에 추가로 평면의 위쪽 방향을 나타내는 벡터 n을 추가해서<br>
(캐릭터 시선 X 목표물)ᆞn의 결과가,
- 왼쪽에 있으면 음수
- 오른쪽에 있으면 양수

<br>

### 카메라 트랜스폼의 회전행렬 구하기 (언리얼 축 기준)
카메라에서 목표물까지 벡터 정규화하고 이를 로컬 x축(앞)이라고 하면,<br>
월드 z축(위)와 로컬 x축을 외적하고 로컬 y축(옆)이 나오고,<br>
로컬 x축과 로컬 y축을 외적하면 로컬 z축(위)가 나온다.<br>
로컬 x y z축 벡터로 아핀 공간 행렬 만들면 카메라 트랜스폼의 회전행렬이 나온다.

<br>

### 백페이스 컬링
폴리곤의 노멀벡터가 카메라가 향하는 벡터와 마주보면 렌더링하고, 마주보지 않으면 렌더링 하지 않는 것. 삼각형 폴리곤일 경우, 두 벡터 외적해서 노멀벡터 구해주고, 카메라 정면 벡터랑 내적해서 음수면 렌더링 해주고, 양수면 렌더링 안 함.

<br>

---
책 [이득우의 게임수학] 저자: 이득우, 출판: 책만<br>
1장부터 11장까지
